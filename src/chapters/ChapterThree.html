<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/src/css/output.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-neutral-50 text-neutral-900 font-inter leading-relaxed">
   <header class="site-header bg-white shadow-lg sticky top-0 z-50">
    <div class="container mx-auto px-4 py-4 flex justify-between items-center">
        <!-- Logo / Brand -->
        <h1 class="brand text-2xl font-bold text-primary">Group 1</h1>

        <!-- Mobile menu toggle -->
        <div class="md:hidden">
            <input type="checkbox" id="menu-toggle" class="hidden peer" />
            <label for="menu-toggle" class="flex flex-col cursor-pointer space-y-1">
                <span class="w-6 h-0.5 bg-neutral-800 transition-all duration-300 peer-checked:rotate-45 peer-checked:translate-y-2"></span>
                <span class="w-6 h-0.5 bg-neutral-800 transition-all duration-300 peer-checked:opacity-0"></span>
                <span class="w-6 h-0.5 bg-neutral-800 transition-all duration-300 peer-checked:-rotate-45 peer-checked:-translate-y-2"></span>
            </label>
        </div>


         <audio autoplay loop>
          <source src="/src/assets/angke.mp3" type="audio/mp3">
          Your browser does not support the audio element.
      </audio>
        <!-- Desktop nav -->
        <nav class="hidden md:flex space-x-6">
            <a href="/src/index.html" class="nav-link">Home</a>
            <a href="/src/chapters/ChapterOne.html" class="nav-link">Chapter 1</a>
            <a href="/src/chapters/ChapterTwo.html" class="nav-link">Chapter 2</a>
            <a href="/src/chapters/ChapterThree.html" class="nav-link active">Chapter 3</a>
            <a href="/src/chapters/ChapterFour.html" class="nav-link">Chapter 4</a>
        </nav>
    </div>

    <!-- Mobile nav -->
    <nav class="md:hidden bg-white shadow-lg overflow-hidden max-h-0 peer-checked:max-h-screen transition-all duration-500">
        <div class="flex flex-col px-4 py-2 space-y-2">
            <a href="/src/index.html" class="nav-item">Home</a>
            <a href="/src/chapters/ChapterOne.html" class="nav-item">Chapter 1</a>
            <a href="/src/chapters/ChapterTwo.html" class="nav-item">Chapter 2</a>
            <a href="/src/chapters/ChapterThree.html" class="nav-item active">Chapter 3</a>
            <a href="/src/chapters/ChapterFour.html" class="nav-item">Chapter 4</a>
        </div>
    </nav>
</header>


    <main class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="chapter-header text-center mb-8">
            <h2 class="text-4xl font-bold text-neutral-800 mb-2">Agile Software Development</h2>
            <p class="text-lg text-neutral-600">Chapter 3</p>
        </header>

        <section class="chapter-objective chapter-card mb-8">
            <h3 class="section-title">Objectives</h3>
            <p class="mb-4">The objective of this chapter is to introduce you to agile software development methods. When you have read the chapter, you will:</p>
            <ul class="list-disc list-inside space-y-2">
                <li>Understand the rationale for agile software development methods, the agile manifesto, and the differences between agile and plan-driven development;</li>
                <li>Know the key practices in extreme programming and how these relate to the general principles of agile methods;</li>
                <li>Understand the Scrum approach to agile project management;</li>
                <li>Understand the concepts of user stories, story points, and velocity;</li>
                <li>Be aware of the issues and problems of scaling agile methods to the development of large software systems.</li>
            </ul>
        </section>

        <section class="chapter-content chapter-card mb-8">
            <h4 class="section-title">Contents</h4>
            <ul class="list-disc list-inside space-y-1">
                <li>3.1 Agile methods</li>
                <li>3.2 Plan-driven and agile development</li>
                <li>3.3 Extreme programming</li>
                <li>3.4 Agile project management</li>
                <li>3.5 Scaling agile methods</li>
            </ul>
        </section>

        <section class="chapter-card mb-8">
    <h3 class="section-title">Introduction</h3>
    <p>
        Businesses now operate in a global, rapidly changing environment. They have to respond to new opportunities and markets, changing economic conditions, and the emergence of competing products and services. Software is part of almost all business operations so new software is developed quickly to take advantage of new opportunities and to respond to competitive pressure. Rapid development and delivery is therefore now often the most critical requirement for software systems. Many businesses are willing to trade off software quality and compromise on requirements to achieve faster deployment of the software that they need.
    </p>

    <p class="mt-4">
        Because these businesses are operating in a changing environment, it is often impossible to derive a complete set of stable software requirements. The initial requirements inevitably change because customers cannot always predict how a system will affect working practices or interact with other systems. Often, the real requirements only become clear after users gain experience with the system. Even then, requirements may continue to change due to external factors, which may leave the software outdated by the time it is delivered.
    </p>

    <p class="mt-4">
        Traditional plan-driven process models, such as the waterfall model, rely on extensive up-front specification and design. When requirements change, redesign and rework are necessary, and this slows development. As a result, the final software may be delivered long after it was originally needed.
    </p>

    <p class="mt-4">
        For systems such as safety-critical control systems, where complete analysis is essential, a plan-driven approach is appropriate. However, in fast-moving business environments, this can lead to software being delivered too late to be useful. Therefore, development processes that focus on rapid delivery and adaptability are essential.
    </p>

    <p class="mt-4">
        Rapid development ideas date back to the 1980s with incremental development and fourth-generation languages. However, rapid development became more influential in the late 1990s with agile methods such as DSDM, Scrum, and Extreme Programming.
    </p>

    <p class="mt-4">
        Rapid software development produces useful software in increments. Each increment adds new functionality, allowing users to evaluate and refine system requirements continuously.
    </p>

    <ul class="list-disc list-inside mt-4 space-y-2">
        <li>The processes of specification, design, and implementation are interleaved, with minimal documentation.</li>
        <li>The system is developed in multiple small versions, each reviewed by users who can request changes or new features.</li>
        <li>User interfaces are often built using tools that allow rapid prototyping through visual design environments.</li>
    </ul>

    <p class="mt-4">
        Agile methods are incremental development methods where new releases are produced every few weeks. They rely on customer involvement, quick feedback, and informal communication instead of extensive documentation.
    </p>
</section>


<section class="chapter-card mb-8">
    <h3 class="section-title"> Agile Methods</h3>
    <p>
        In the 1980s and early 1990s, improving software was believed to depend on careful project planning, formalized quality assurance, modeling using CASE tools, and rigorous development processes. These approaches were used for large software systems such as aerospace and government systems, developed by large teams over many years.
    </p>

    <p class="mt-4">
        These plan-driven approaches involve high overhead in planning, documentation, and coordination. This overhead is justified for large, long-lived, and critical systems. However, when applied to small or medium business systems, the overhead dominates development. More effort is spent planning how to develop than actually building and testing the software.
    </p>

    <p class="mt-4">
        Dissatisfaction with heavyweight methods led to the proposal of new “agile” approaches in the 1990s. These approaches allowed developers to focus more on software itself rather than documentation and formal processes.
    </p>
</section>
        


<section class="chapter-card mb-8">
    <p>
        Agile methods rely on an incremental approach to specification, development, and delivery. They are well-suited to systems where requirements change rapidly during development. The goal is to deliver working software quickly, allowing customers to request changes that can be added in later iterations. Agile processes avoid unnecessary documentation and tasks that have limited long-term value.
    </p>

    <p class="mt-4">
        The philosophy behind agile development is summarized in the Agile Manifesto:
    </p>

    <blockquote class="border-l-4 border-neutral-400 pl-4 italic mt-4">
        We are uncovering better ways of developing software by doing it and helping others do it.  
        Through this work we have come to value:  
        <br><br>
        Individuals and interactions over processes and tools  
        Working software over comprehensive documentation  
        Customer collaboration over contract negotiation  
        Responding to change over following a plan  
        <br><br>
        That is, while there is value in the items on the right, we value the items on the left more.
    </blockquote>

    <p class="mt-4">
        Well-known agile methods include Extreme Programming (XP), Scrum, Crystal, Adaptive Software Development, DSDM, and Feature-Driven Development. Some organizations combine agile practices with traditional system modeling, leading to agile modeling approaches.
    </p>

    <p class="mt-4">
        Although these methods differ, they share core principles derived from the Agile Manifesto. Later sections focus on two widely used approaches: Extreme Programming (Section 3.3) and Scrum (Section 3.4).
    </p>

    <p class="mt-4">Agile methods are especially successful in:</p>
    <ul class="list-disc list-inside space-y-1 mt-2">
        <li>Product development for small or medium-sized commercial software.</li>
        <li>Custom system development where the customer actively participates and external constraints are limited.</li>
    </ul>

</section>

<section class="chapter-card mb-8">
    <p>
        Extreme programming (XP) is one of the most widely used agile methods. It pushes well-known good practices, such as iterative development, to an extreme level. In XP, multiple versions of a system may be developed, integrated, and tested within a single day.
    </p>
</section>


<section class="chapter-card mb-8">
    <p>
        As agile methods have grown in popularity, there has been interest in applying them to large and critical systems. However, their reliance on small, closely collaborating teams makes scaling difficult. Critical systems, which require safety, security, and dependability assurance, often need additional documentation and analysis beyond typical agile practices.
    </p>

    <p class="mt-4">
        In practice, the principles of agile development can be challenging to achieve:
    </p>

    <ul class="list-disc list-inside space-y-2 mt-2">
        <li>Customer representatives may be unable to dedicate enough time or represent all stakeholders.</li>
        <li>Not all team members may thrive in highly collaborative environments.</li>
        <li>Prioritizing changes becomes difficult when many stakeholders are involved.</li>
        <li>Maintaining simplicity in design requires extra effort, which may be sacrificed under time pressure.</li>
        <li>Large organizations may struggle to shift from formal, process-driven cultures to flexible team-defined workflows.</li>
    </ul>
</section>


<section class="chapter-card mb-8">
    <p>
        Agile development also raises contracting challenges when external suppliers are involved. Traditional contracts specify requirements upfront, but agile development requires evolving requirements. Instead, contracts are often based on developer time and resources. This can benefit both customer and developer, but disagreements may arise if the project encounters problems.
    </p>

    <p class="mt-4">
        Agile methods are widely discussed for new system development, but many software engineering activities focus on maintaining and evolving existing systems. Two questions arise when applying agile methods to maintenance:
    </p>

    <ul class="list-disc list-inside space-y-2 mt-2">
        <li>Are systems developed with minimal documentation maintainable in the long term?</li>
        <li>Can agile practices effectively support ongoing changes after release?</li>
    </ul>

    <p class="mt-4">
        Agile practitioners argue that maintainability depends on writing high-quality, readable code rather than extensive documentation. However, maintainers often rely on a clear requirements document to understand system purpose. Agile development may lack this, making change impact harder to assess.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Agile methods can make system maintenance more difficult and expensive because less documentation is produced and more knowledge is kept within the development team. When that team changes, this knowledge is lost.
    </p>

    <p class="mt-4">
        However, agile practices themselves can be effectively used during maintenance. Incremental delivery, designing for change, and keeping systems simple support efficient modification and evolution of software.
    </p>

    <p class="mt-4">
        The key challenge after delivery is maintaining customer involvement. While full-time customer representation is common during development, it becomes harder to justify during maintenance when changes are less frequent, leading to communication issues and unclear new requirements.
    </p>
</section>


<section class="chapter-card mb-8">
    <p>
        Agile methods rely heavily on shared understanding within the development team rather than extensive documentation. If the original team disbands, this implicit system knowledge is lost.
    </p>

    <p class="mt-4">
        Bringing new developers into the project becomes difficult, as they lack the background knowledge needed to understand system structure and decisions, which can slow down maintenance and future improvements.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Supporters of agile methods strongly promote their benefits, sometimes overlooking limitations. Critics, however, may exaggerate the problems.
    </p>

    <p class="mt-4">
        A balanced approach combines agile practices with useful techniques from plan-driven development, forming a hybrid strategy that adapts to the project’s needs.
    </p>
</section>


<section class="chapter-card mb-8">
    <p>
        Agile development focuses on design and implementation as central activities, integrating requirements and testing throughout. Plan-driven development separates the process into distinct stages, each producing documents used in the next stage.
    </p>

    <p class="mt-4">
        In plan-driven methods, iteration happens inside each phase, while in agile methods, iteration spans across activities, evolving requirements and design together.
    </p>
</section>


<section class="chapter-card mb-8">
    <p>
        A plan-driven process can still support incremental delivery. Agile teams may also produce documentation when necessary. In practice, most projects use a mixture of agile and plan-driven methods.
    </p>

    <p class="mt-4">
        The balance depends on project size, customer involvement, team skills, regulatory requirements, system lifetime, and development environment.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Requirements in XP are expressed as user stories, which are broken down into tasks. Programmers work in pairs and write tests before coding. New code is accepted only if all tests pass when integrated.
    </p>

    <p class="mt-4">
        XP supports frequent and small releases, ensuring that feedback is frequent and development remains aligned with customer needs.
    </p>
</section>

<section class="chapter-card mb-8">
    <ul class="list-disc list-inside space-y-2">
        <li><strong>Incremental development:</strong> Small, frequent system releases based on user stories.</li>
        <li><strong>Customer involvement:</strong> Customer is part of the development team and defines acceptance tests.</li>
        <li><strong>People before process:</strong> Pair programming, shared code ownership, and sustainable working hours.</li>
        <li><strong>Embracing change:</strong> Continuous integration, test-first development, and refactoring.</li>
        <li><strong>Simplicity:</strong> Systems are kept clean and simple, avoiding unnecessary complexity.</li>
    </ul>
</section>

<section class="chapter-card mb-8">
    <p>
        The customer collaborates with the development team to create user stories, which describe system behavior from the user’s perspective. These stories are written on story cards.
    </p>

    <p class="mt-4">
        In the planning game, each story is broken down into development tasks and estimated. The customer prioritizes which stories will be implemented next, typically targeting functionality that can be delivered in about two weeks.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        If uncertainties or architectural questions arise, XP teams perform a “spike” — a short exploratory activity used to research solutions. Some spikes are also performed to prepare documentation.
    </p>

    <p class="mt-4">
        New software versions may be built several times per day, and new releases are delivered about every two weeks. Release deadlines are fixed; if problems arise, features are removed rather than delaying the release.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Incremental development can degrade structure over time. XP addresses this through continuous refactoring — improving code quality, removing duplication, and reorganizing structure as the software evolves.
    </p>

    <p class="mt-4">
        However, in practice, refactoring may be skipped when deadlines are tight, and some changes require restructuring at the architectural level.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Many organizations adapt XP to fit their context. Some may not use pair programming or user stories strictly, but most retain the core practices of small releases, test-first development, and continuous integration.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        XP emphasizes program testing to prevent errors from accumulating as the system evolves. Testing in XP focuses on:
    </p>

    <ul class="list-disc list-inside space-y-2 mt-2">
        <li>Test-first development</li>
        <li>Incremental test creation based on user stories</li>
        <li>User involvement in defining test acceptance conditions</li>
        <li>Automated testing tools</li>
    </ul>

    <p class="mt-4">
        Writing tests before coding clarifies requirements, prevents misunderstandings, and keeps testing synchronized with implementation.
    </p>
</section>


<section class="chapter3-page1">
    <p>70 Chapter 3 ■ Agile software development</p>
</section>

<section class="chapter3-images">
    <img src="images/ChapterThree/70.png" alt="">
</section>

<section class="chapter-card mb-8">
    <p>
        The role of the customer in the testing process is to help develop acceptance tests
        for the stories that are to be implemented in the next release of the system. As 
        discussed in Chapter 8, acceptance testing uses customer data to check that the 
        system meets real customer needs.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        In XP, acceptance testing is incremental. The customer writes tests as development 
        progresses so all new code is validated. For the story in Figure 3.5, acceptance 
        tests would include scenarios such as:
    </p>

    <ul class="list-disc list-inside space-y-2 mt-2">
        <li>Changing the dose of a drug</li>
        <li>Selecting a new drug</li>
        <li>Using the formulary to find a drug</li>
    </ul>
</section>

<section class="chapter-card mb-8">
    <p>
        A difficulty in XP is that customers may not always have time to participate in 
        acceptance test development. Some customers feel that providing requirements is 
        already a sufficient contribution and may be reluctant to continue involvement.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Test automation is essential in test-first development. Tests are written before 
        implementation and executed as standalone components that simulate input and 
        verify output. Automated test frameworks, such as JUnit, make this possible.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Automated testing provides a quick way to run tests whenever functionality changes, 
        allowing new issues to be caught immediately.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Test-first development and automation produce many tests, but this does not 
        guarantee complete testing. Limitations include:
    </p>

    <ol class="list-decimal list-inside space-y-2 mt-2">
        <li>
            Programmers may take shortcuts when writing tests, leading to incomplete coverage.
        </li>
        <li>
            Some tests, especially for complex user interfaces, are difficult to write incrementally.
        </li>
        <li>
            It is hard to judge if the full system has been adequately tested, meaning some bugs
            may remain undetected.
        </li>
    </ol>
</section>

<section class="chapter3-page">
    <p>3.3 ■ Extreme programming 71</p>
</section>

<section class="chapter-card mb-8">
    <h3 class="text-lg font-semibold mb-2">3.3.2 Pair Programming</h3>

    <p>
        XP also introduces pair programming, where two programmers work together at 
        the same workstation. Pairs change regularly so the entire team works collaboratively.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Advantages of pair programming include:
    </p>

    <ol class="list-decimal list-inside space-y-2 mt-2">
        <li>
            It promotes collective ownership and responsibility for the system.
        </li>
        <li>
            It acts as an informal review process, reducing the number of coding errors.
        </li>
        <li>
            It supports refactoring by making improvements more acceptable to the team.
        </li>
    </ol>
</section>

<section class="chapter3-page1">
    <p>72 Chapter 3 ■ Agile software development</p>
</section>

<section class="chapter-card mb-8">
    <p>
        While pair programming may seem less efficient, studies show mixed productivity 
        results. Some studies suggest equal output due to fewer mistakes and rework, while 
        others show reduced productivity but higher knowledge sharing, which reduces 
        project risk.
    </p>
</section>

<section class="chapter3-page">
    <h3>3.4 Agile Project Management</h3>
</section>

<section class="chapter-card mb-8">
    <p>
        Software project managers are responsible for ensuring timely and budget-conscious 
        project delivery. Traditional plan-driven management assumes stable requirements, 
        making it incompatible with agile methods where change is expected.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Agile development requires a different management approach suited to incremental 
        delivery, rapid releases, and evolving requirements. Scrum focuses on managing 
        iterative development rather than specifying technical practices.
    </p>
</section>

<section class="chapter-card mb-8">
    <p>
        Scrum development involves three phases:
    </p>

    <ul class="list-disc list-inside space-y-2 mt-2">
        <li>Outline planning and architecture design</li>
        <li>Repeated sprint cycles of development</li>
        <li>System deployment</li>
    </ul>
</section>



<section class="chapter-card mb-8">
    <ul class="list-disc list-inside space-y-2">
        <li>Need for a detailed specification before coding → Plan-driven.</li>
        <li>Ability to deliver incrementally and receive quick feedback → Agile.</li>
        <li>Small, co-located team → Agile works well.</li>
        <li>Large or complex systems requiring deep upfront analysis → Plan-driven.</li>
        <li>Long system lifetime → More documentation may be necessary.</li>
        <li>Poor tooling → May require more design documentation.</li>
        <li>Distributed or outsourced teams → Need planned documentation.</li>
        <li>Traditional engineering culture → Plan-driven preferred.</li>
        <li>Lower-skill programmers → Plan-driven provides clearer structure.</li>
        <li>Regulated systems → Documentation required → Plan-driven.</li>
    </ul>
</section>

        
    </main>

    <footer class="site-footer bg-neutral-800 text-white py-6 animate-fadeInUp">
        <div class="container mx-auto px-4 text-center">
            <nav class="footer-nav mb-4">
            </nav>
            <p class="footer-copy">© 2025 Group 1, BSIT 3A</p>
        </div>
    </footer>
</body>
</html>